glEnable(GL_DEPTH_TEST);
glEnable(GL_STENCIL_TEST);
glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE); 
/*
При следующей встрече функции glStencilFunc все фрагменты успешно прошедшие тест глубины и трафарета заполняются тем,
 что указано во втором параметре функции glStencilFunc, то есть ref (У нас это "1").
*/

/* Что значат параметры функции glStencilOp:
[1] GL_KEEP    Если тест трафарета не пройден сохраняется текущее значение трафарета.
[2] GL_KEEP    Если тест трафарета пройден, но тест глубины — нет cохраняется текущее значение трафарета.
[3] GL_REPLACE Если пройдены и тест трафарета, и тест глубины - значение трафарета заменяется значением ref, установленным с помощью функции glStencilFunc()..

*/
  

While
{
	
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);  //Очистка буфера цвета, глубины и трафарета

	 
	glStencilMask(0x00); // убеждаемся, что мы не обновляем буфер трафарета во время рисования пола, так как каждый бит в буфере трафарета становится нулем (отключение записи)
	normalShader.use();
	DrawFloor()  
  
	// Контур и объём модели заполняется в буффере трафарета еденицами
	glStencilFunc(GL_ALWAYS, 1, 0xFF);  // все фрагменты должны пройти тест трафарета
	glStencilMask(0xFF);  // включаем запись в буфер трафарета // каждый бит в буфере трафарета становится еденицей, так как это "приказала" функция glStencilOp в начале программы.
	DrawTwoContainers();
  
	// Сначала указывается правило, что фрагменты у которых буффер трафарета не содержит едениц проходят тест. 
	// Потом отключается запись в маску, что бы новоотрисованные фрагменты не испортили маску.
	// Выключается буфер глубины, что бы фрагменты нормальной модели отрисованные первыми не были закрыты новоотрисованными фрагментами.
	// Потом отрисовывается контур-модель (не портит маску и не налазит на уже отрисованную основную модель)
	glStencilFunc(GL_NOTEQUAL, 1, 0xFF); //Всякий раз когда значение трафарета не равно 1 фрагмент успешно проходит тест
	glStencilMask(0x00); // каждый бит в буфере трафарета становится нулем (отключение записи)
	glDisable(GL_DEPTH_TEST); // Отключаем тестирование глубины, что бы фрагменты нормальной модели отрисованные первыми не были закрыты новоотрисованными фрагментами.
	shaderSingleColor.use(); // Отрисовываем чуть увеличеную версию модели с помощью другого (одноцветного) шейдера.
	DrawTwoScaledUpContainers(); 

	// Включается запись маски, все фрагменты должны пройти тест трафарета, включается тестирование глубины.
	glStencilMask(0xFF); // включаем запись в буфер трафарета (Не знаю зачем. Честно. Думаю что б на след кадре предметы могли перезаписать буфер трафарета)
	glStencilFunc(GL_ALWAYS, 1, 0xFF);   // все фрагменты должны пройти тест трафарета (Почему? Не знаю. :-( Без этой строчки кстати всё работает)
	

	glEnable(GL_DEPTH_TEST);  // Включаем тестирование глубины, что б следующие фрагменты закрывали старые фрагменты собой.
}